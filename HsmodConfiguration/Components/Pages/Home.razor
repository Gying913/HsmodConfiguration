@page "/"

@inject Configuration conf
@using System.Timers
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService
<PageTitle>常规设置</PageTitle>

<MudStack Row="true" Wrap="Wrap.Wrap" Justify="Justify.SpaceEvenly">
    <!-- 原有连接设置区域 -->
    <MudPaper Class=" pa-3 ma-2 align-center" Elevation="3">
        <div style="display: flex;justify-content: center;align-items: center;flex-wrap: wrap;">
            <MudTextField Class="ma-2" @bind-Value="Configuration.url" Label="Url地址" Variant="Variant.Outlined" Margin="Margin.Dense" />
            <MudTextField Class="ma-2" @bind-Value="Configuration.port" Label="端口" Variant="Variant.Outlined" Margin="Margin.Dense" />

            @if (_processing)
            {
                <MudButton Class="ma-2" Disabled="@_processing" OnClick="relink" Variant="Variant.Filled" Color="Color.Primary">
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <MudText>正在连接服务器</MudText>
                </MudButton>
            }
            else
            {
                if (Configuration.login)
                {
                    <MudButton Class="ma-2 display: inline-block" Disabled="@_processing" OnClick="relink" Variant="Variant.Filled" Color="Color.Success">
                        <MudText>已连接插件</MudText>
                    </MudButton>
                    <MudPaper Class="ma-2 pa-2">PID: @Configuration.pid</MudPaper>
                }
                else
                {
                    <MudButton Class="ma-2" Disabled="@_processing" OnClick="relink" Variant="Variant.Filled" Color="Color.Error">
                        <MudText>失败请重连</MudText>
                    </MudButton>
                }
            }
        </div>
    </MudPaper>

    <!-- 游戏路径与插件管理区域（卸载按钮强制显示） -->
    <MudPaper Class="pa-3 ma-2 align-center" Elevation="3">
        <div style="display: flex;justify-content: center;align-items: center;flex-wrap: wrap;">
            <MudTextField Class="ma-2" Disabled="true" @bind-Value="Configuration.GamePath" Label="《炉石传说》安装路径" Variant="Variant.Outlined" />
            <MudButton Class="ma-2" OnClick="pickFile" Variant="Variant.Filled" Color="Color.Info">
                <MudText>手动选择路径</MudText>
            </MudButton>

            @if (_Downloading)
            {
                <MudProgressLinear Color="Color.Info" Size="Size.Large" Value="@((int)(_DownloadValue + GitHub.Downloadprogress * 0.7))" Class="my-7">
                    <MudText Typo="Typo.subtitle1" Color="Color.Dark">
                        <b>@_DownloadText</b>
                    </MudText>
                </MudProgressLinear>
            }
            else
            {
                <!-- 安装/重装按钮 -->
                if (Configuration.GamePath == "" || _processing || Configuration.login)
                {
                    <MudTooltip Text="未获取到游戏路径或游戏未关闭" Arrow="true">
                        <MudButton Disabled="true" Class="ma-2" OnClick="Download" Variant="Variant.Filled" Color="Color.Success">
                            <MudText>安装HsMod插件</MudText>
                        </MudButton>
                    </MudTooltip>
                }
                else
                {
                    if (Configuration.pluginVersion == null)
                    {
                        <MudTooltip Text="安装前请确认游戏已关闭" Arrow="true">
                            <MudButton Class="ma-2" OnClick="Download" Variant="Variant.Filled" Color="Color.Success">
                                <MudText>安装HsMod插件</MudText>
                            </MudButton>
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text=@($"当前插件版本：{Configuration.pluginVersion}，安装前请确认游戏已关闭") Arrow="true">
                            <MudButton Class="ma-2" OnClick="Download" Variant="Variant.Filled" Color="Color.Success">
                                <MudText>重装HsMod插件</MudText>
                            </MudButton>
                        </MudTooltip>
                    }
                }

                <!-- 卸载按钮：取消原有条件，强制显示（关键修改） -->
                <MudTooltip Text="卸载将删除BepInEx目录及插件，游戏本体不受影响" Arrow="true">
                    <MudButton Class="ma-2"
                               OnClick="Uninstall"
                               Variant="Variant.Filled"
                               Color="Color.Error"
                               Disabled="_processing || _Downloading || string.IsNullOrEmpty(Configuration.GamePath)">
                        <MudText>卸载HsMod插件</MudText>
                    </MudButton>
                </MudTooltip>
            }
        </div>
    </MudPaper>

    <!-- 原有配置项区域 -->
    @if (Configuration.hsmodcfg.Count > 0)
    {
        foreach (List<string> card in _List)
        {
            <MudPaper Class="pa-3 ma-2" Elevation="3">
                @foreach (string item in card)
                {
                    var cfg = Configuration.hsmodcfg[item];
                    if (cfg.type == typeof(int))
                    {
                        if (cfg.acceptableRange != null & cfg.acceptableRange.Count == 2)
                        {
                            <!-- 关键修复：添加 @key 确保绑定稳定，取消高频重渲染影响 -->
                            <MudNumericField @key="cfg.key" @bind-Value="cfg.intValue" Label="@cfg.key" HelperText="@cfg.ps" Variant="Variant.Outlined" Min="cfg.acceptableRange[0]" Max="cfg.acceptableRange[1]" />
                        }
                        else
                        {
                            <MudNumericField @key="cfg.key" @bind-Value="cfg.intValue" Label="@cfg.key" HelperText="@cfg.ps" Variant="Variant.Outlined" Min="0" Max="2147483647" />
                        }
                    }
                    else if (cfg.type == typeof(bool))
                    {
                        <MudTooltip Text="@cfg.ps" Arrow="true">
                            <MudSwitch @key="cfg.key" @bind-Value="cfg.boolValue" ThumbIcon="@(cfg.boolValue == true ? Icons.Material.Filled.Done : Icons.Material.Filled.Close)" HelperText="@cfg.ps" ThumbIconColor="@(cfg.boolValue == true ? Color.Success : Color.Error)">@cfg.key</MudSwitch>
                        </MudTooltip>
                    }
                    else if (cfg.type == typeof(string))
                    {
                        if (cfg.acceptValue != null)
                        {
                            <MudSelect @key="cfg.key" @bind-Value="cfg.stringValue"
                                       Variant="Variant.Outlined"
                                       Label="@cfg.key"
                                       HelperText="@cfg.ps">
                                @foreach (var value in cfg.acceptValue)
                                {
                                    <MudSelectItem Value="value">@value</MudSelectItem>
                                }
                            </MudSelect>
                        }
                    }
                }
            </MudPaper>
        }
    }
</MudStack>

@code {
    // 原有变量全部保留
    private bool _Downloading = false;
    private bool _processing = false;
    private int _DownloadValue = 0;
    private string _DownloadText = "下载中";
    private List<List<string>> _List = [["快捷键状态", "变速齿轮状态", "显示FPS", "游戏帧率", "变速倍率", "开包加速", "快速战斗"], ["自动开包", "自动分解", "自动开盒", "自动举报", "自动领奖"], ["允许掉线", "游戏内消息", "结算展示", "弹出消息", "报错退出", "弹出响应"], ["收藏卡牌数量", "显示卡牌ID", "自动置换卡牌", "显示放弃"]];
    private Timer timer = new Timer(1000);
    // 新增：标记是否正在输入，避免定时器干扰
    private bool _isInputting = false;

    // 原有方法全部保留
    async protected override void OnInitialized()
    {
        if (Configuration.firstOpen)
        {
            await Configuration.getGamePath();
            await Configuration.getPluginVersion();
            await relink();
        }
        timer.Elapsed += Timer_Elapsed;
        timer.Start();
    }

    // 关键修复：优化定时器重渲染逻辑，输入时跳过
    private void Timer_Elapsed(object sender, ElapsedEventArgs e)
    {
        // 输入时不触发重渲染，避免焦点丢失
        if (!_isInputting)
        {
            InvokeAsync(() => StateHasChanged());
        }
    }

    async Task Download()
    {
        try
        {
            GitHub.Downloadprogress = 0;
            _Downloading = true;
            _DownloadText = "清理安装目录";
            string fromDir = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Addins");
            string toDir = System.IO.Path.GetDirectoryName(Configuration.GamePath);
            await FileIO.DeleteDirectory($@"{toDir}\BepInEx");
            _DownloadValue = 10;
            _DownloadText = "复制BepInEx";
            await FileIO.CopyDirectory(fromDir, toDir);
            await FileIO.CreateDirectory($@"{toDir}\BepInEx\plugins");
            _DownloadValue = 20;
            _DownloadText = "正在获取HsMod最新版本号";
            var result = await GitHub.GetLatestReleaseDownloadUrl("Gying091", "HsMod");
            _DownloadValue = 30;
            _DownloadText = $"下载最新版本{result.version}HsMod";
            await GitHub.DownloadFileWithProgressAsync(result.url, $@"{toDir}\BepInEx\plugins\HsMod.dll");
            _DownloadText = "HsMod安装完成，请运行游戏后点击重连";
            await Configuration.getPluginVersion();
            await Task.Delay(5000);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            var parameters = new DialogParameters<HsmodConfiguration.Components.Dialog.Onlysubmit>
            {
                { x => x.ContentText, e.Message },
                { x => x.ButtonText, "好的" },
                { x => x.Color, Color.Error }
            };
            var options = new DialogOptions() { CloseButton = false, MaxWidth = MaxWidth.ExtraSmall };
            await DialogService.ShowAsync<HsmodConfiguration.Components.Dialog.Onlysubmit>("出错了", parameters, options);
        }
        _Downloading = false;
        _DownloadValue = 0;
    }

    async Task pickFile()
    {
        await Configuration.PickFileAsync();
        StateHasChanged();
    }

    async Task relink()
    {
        _processing = true;
        await Task.Delay(1000);
        await Configuration.getAlive();
        _processing = false;
        if (Configuration.login)
        {
            await Configuration.getHsmodCfg();
            await Configuration.getSkinsData();
        }
        Configuration.firstOpen = false;
        StateHasChanged();
    }

    // 卸载方法（简化版，无复杂依赖）
    private async Task Uninstall()
    {
        // 1. JS原生确认弹窗
        bool confirm = await JSRuntime.InvokeAsync<bool>("confirm",
            "⚠️ 确认卸载HsMod插件？\n- 将删除游戏目录下的BepInEx文件夹\n- 游戏本体不受影响\n- 请确保游戏已关闭！");
        if (!confirm) return;

        try
        {
            _Downloading = true;
            _DownloadText = "正在卸载插件...";
            _DownloadValue = 0;

            // 2. 核心卸载逻辑
            if (!string.IsNullOrEmpty(Configuration.GamePath))
            {
                string gameDir = System.IO.Path.GetDirectoryName(Configuration.GamePath);
                string bepInExDir = Path.Combine(gameDir, "BepInEx");

                // 删除BepInEx目录
                if (Directory.Exists(bepInExDir))
                {
                    await FileIO.DeleteDirectory(bepInExDir);
                    _DownloadValue = 80;
                    _DownloadText = "插件目录已删除";
                }
                else
                {
                    _DownloadValue = 80;
                    _DownloadText = "未找到插件目录";
                }

                // 重置配置
                Configuration.pluginVersion = null;
                Configuration.hsmodcfg.Clear();
            }

            // 3. 卸载完成
            _DownloadValue = 100;
            _DownloadText = "卸载完成！";
            await Task.Delay(1500);
            await JSRuntime.InvokeVoidAsync("alert", "✅ HsMod插件卸载成功！");
        }
        catch (Exception e)
        {
            // 失败提示
            await JSRuntime.InvokeVoidAsync("alert", $"❌ 卸载失败：{e.Message}\n请手动删除游戏目录下的BepInEx文件夹");
        }
        finally
        {
            _Downloading = false;
            _DownloadValue = 0;
            StateHasChanged();
        }
    }

    // 新增：输入框焦点事件，标记输入状态
    private void OnInputFocused() => _isInputting = true;
    private void OnInputBlurred() => _isInputting = false;
}